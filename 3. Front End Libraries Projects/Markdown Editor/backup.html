'use strict';

const e = React.createElement;

const convertMarkdown = (text, htmlParsing) => {
  // Variable initializations.

  // This object holds all of our markup styles and their open/close tags.
  const notationObjs = {
    '#': {
      openReplaceText: '<h1>',
      closereplacetext: '</h1>'
    },
    '##': {
      openReplaceText: '<h2>',
      closereplacetext: '</h2>'
    },
    '!@': {
      openReplaceText: '<a href="',
      closereplacetext: '">'
    },
    '!#': {
      openReplaceText: '</a>',
      closereplacetext: '</a>'
    },
    '-@': {
      openReplaceText: '<span class="grey">',
      closereplacetext: '</span>'
    },
    '&@': {
      openReplaceText: '<code>',
      closereplacetext: '</code>'
    },
    '(@': {
      openReplaceText: '<ul><li>',
      closereplacetext: '</li></ul>'
    },
    '(#': {
      openReplaceText: '</li><li>',
      closereplacetext: '</li>'
    },
    '%@': {
      openReplaceText: '<blockquote>',
      closereplacetext: '</blockquote>'
    },
    '**': {
      openReplaceText: '<span class="bold">',
      closereplacetext: '</span>'
    },
    '^@': {
      openReplaceText: '<img src=',
      closereplacetext: '">'
    },
    '\\n': {
      openReplaceText: '<br />',
      closereplacetext: '<br />'
    },
    '\\t': {
      openReplaceText: '&nbsp;&nbsp;&nbsp;&nbsp;',
      closereplacetext: '&nbsp;&nbsp;&nbsp;&nbsp;'
    }
  };
  
  // We store the text as an array of chars with all html tags stripped out immediately.
  const chars = (htmlParsing == 'ON') ? text.split('') : text.replace(/<.*?>/gi, '').split('');
  let finalText = '';
  let found;

  // Initialize notationObjs' sub-objects with state properties set to false.
  for (let o in notationObjs) {
    notationObjs[o]["state"] = false;
  }

  // Look for our sub-patterns at each character to find parsable markup.
  for (var i = 0; i < chars.length; i++) {
    found = false;

    for (let o in notationObjs) {
      const x = notationObjs[o];

      if (i < chars.length - o.length && chars.slice(i, i + o.length).join('') === o) {
        x["state"] = !x["state"];
        finalText = finalText.concat(x["state"] ? x["openReplaceText"] : x["closereplacetext"]);
        i += (o.length - 1);
        found = true;
      }
    }

    if (!found) {
      finalText = finalText + chars[i];
    }
  }
  
  return finalText; 
}

// Main React Class
class MarkdownEditor extends React.Component {
  
  constructor(props) {
    super(props);

    const startString = 
      'Normal.\n' +
      '#A header.#\n' +
      '##A sub-header.##\n' +
      'Links: !@google.com!@Google!#\\n\n' +
      'Inline code: -@Some text-@\\n\n' +
      'Multiline code: &@Some\\nText\\nOn\\nLines&@\\n\n' +
      'Lists: (@Fruit(#Apple(#(#Banana(#(#Coconut(#(@\\n\n' +
      'Block Quote: %@This is it.%@\\n\n' +
      'Image: ^@https://sophielambertx.files.wordpress.com/2014/02/web.png?w=625^@\\n\n' +
      'Enable/Disable <span style="color: red;">HTML</span> with the HTML toggle button below.';

    this.state = {
      textArea1: startString,
      textArea2: convertMarkdown(startString, 'OFF'),
      htmlParsing: 'OFF'
    };

    this.handleChange1 = this.handleChange1.bind(this);
    this.toggleHTML = this.toggleHTML.bind(this);
  }

  handleChange1(event) {
    this.setState({
      textArea1: event.target.value,
      textArea2: convertMarkdown(event.target.value, this.state.htmlParsing)
    });
  }

  toggleHTML() {
    var newState = (this.state.htmlParsing == 'ON') ? 'OFF' : 'ON';

    this.setState({
      htmlParsing: newState,
      textArea2: convertMarkdown(this.state.textArea1, newState)
    });
  }

  render() {
    return (
      <div id="main">
        <h1 id="title">Markdown Previewer</h1>
        <h3>
          Author's Note: The highlight of this markdown previewer was actually parsing the markdown myself, rather than using the 'marked' library that can optionally be used.
          I like my implementation as it is fully dynamic and allows you to quickly add unique markdown fairly effortlessly.
        </h3>
        <div id="sideBySide">
          <textarea id="editor" defaultValue={this.state.textArea1} onChange={this.handleChange1}></textarea>
          <div id="preview" dangerouslySetInnerHTML={{ __html: this.state.textArea2}}></div>
        </div>
        <h3>Enable/Disable HTML with the following button:</h3>
        <button onClick={this.toggleHTML}>{this.state.htmlParsing}</button>
      </div>
    );
  }
}

const domContainer = document.querySelector('#markdown_editor_container');
ReactDOM.render(e(MarkdownEditor), domContainer);

/*

      <div id="quote-box" span="display: flex; justify-content: center">
        <q id="text">{this.state.quote}</q>
        <p id="author">{this.state.author}</p>
        <button type="button" className="btn btn-primary" id="new-quote" onClick={this.generateNewQuote}>Generate</button>
        <br />
        <a id="tweet-quote" className="twitter-share-button" href={'https://twitter.com/intent/tweet?text=' + this.state.quote} target='_blank'>
          Tweet
        </a>
      </div>
      */